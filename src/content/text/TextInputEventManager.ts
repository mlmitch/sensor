// SPDX-License-Identifier: AGPL-3.0-or-later

// Copyright (C) 2020 Mitchell Wasson

// This file is part of Weaklayer Sensor.

// Weaklayer Sensor is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.

// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

import { HTMLInputEventManager } from "./capture/HTMLInputEventManager"
import { TextCaptureEvent } from "../../common/events/internal/TextCaptureEvent"

export class TextInputEventManager {

    private readonly htmlInputEventManager: HTMLInputEventManager

    constructor(windowReference: number, windowLocationReferenceProducer: () => number, textInputEventConsumer: (e: TextCaptureEvent) => void) {

        this.htmlInputEventManager = new HTMLInputEventManager(windowReference, () => windowLocationReferenceProducer(), (event) => textInputEventConsumer(event))

        // Set up listeners for all events that could indicate text being inputted into the page

        // input events
        window.addEventListener("input", (e) => this.processEvent(e), { capture: true, once: false, passive: true })

        // keyboard events
        window.addEventListener("keydown", (e) => this.processEvent(e), { capture: true, once: false, passive: true })
        // Note: keyup seems redundant to the data you get in keydown
        // window.addEventListener("keyup", (e) => this.processEvent(e), { capture: true, once: false, passive: true })

        // composition events
        // Note: composition events don't really seem to add any
        //       additional data that we don't already get with other event types
        //window.addEventListener("compositionstart", (e) => this.processEvent(e), { capture: true, once: false, passive: true })
        //window.addEventListener("compositionupdate", (e) => this.processEvent(e), { capture: true, once: false, passive: true })
        //window.addEventListener("compositionend", (e) => this.processEvent(e), { capture: true, once: false, passive: true })

        // clipboard events
        window.addEventListener("paste", (e) => this.processEvent(e), { capture: true, once: false, passive: true })

        // drag events
        window.addEventListener("drag", (e) => this.processEvent(e), { capture: true, once: false, passive: true })
        window.addEventListener("dragend", (e) => this.processEvent(e), { capture: true, once: false, passive: true })
        window.addEventListener("dragenter", (e) => this.processEvent(e), { capture: true, once: false, passive: true })
        window.addEventListener("dragstart", (e) => this.processEvent(e), { capture: true, once: false, passive: true })
        window.addEventListener("dragleave", (e) => this.processEvent(e), { capture: true, once: false, passive: true })
        window.addEventListener("dragover", (e) => this.processEvent(e), { capture: true, once: false, passive: true })
        window.addEventListener("drop", (e) => this.processEvent(e), { capture: true, once: false, passive: true })


    }

    private processEvent(event: Event) {
        // only consider events generated by the browser
        // this should guard against adversarial web pages generating events to 
        if (event.isTrusted) {
            if (event instanceof InputEvent) {
                this.htmlInputEventManager.trackTextInput(event)
            } else if (event instanceof KeyboardEvent) {
                this.processKeyboardEvent(event)
            } else if (event instanceof CompositionEvent) {
                this.processCompositionEvent(event)
            } else if (event instanceof ClipboardEvent) {
                this.processClipboardEvent(event)
            } else if (event instanceof DragEvent) {
                this.processDragEvent(event)
            }
        }
    }

    private processKeyboardEvent(keyboardEvent: KeyboardEvent) {
        console.log(keyboardEvent.type)
        console.log(keyboardEvent.key)
        console.log(keyboardEvent.key)
    }

    private processCompositionEvent(compositionEvent: CompositionEvent) {
        console.log(compositionEvent.type)
        console.log(compositionEvent.data)
    }

    private processClipboardEvent(clipboardEvent: ClipboardEvent) {
        console.log(clipboardEvent.type)
        const paste = clipboardEvent.clipboardData?.getData('text');
        console.log(paste)
    }

    private processDragEvent(dragEvent: DragEvent) {
        const dataTransfer = dragEvent.dataTransfer
        if (dataTransfer) {
            const text: string = dataTransfer.getData("text")
            if (text !== '') {
                console.log(dragEvent.type)
                console.log(text)
            }
        }
    }
}

